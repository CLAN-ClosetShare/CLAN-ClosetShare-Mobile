import 'package:dartz/dartz.dart';
import '../../../../core/error/failures.dart';
import '../../domain/entities/closet_entity.dart';
import '../../domain/entities/closet_item_entity.dart';
import '../../domain/repositories/closet_repository.dart';
import '../datasources/closet_remote_data_source.dart';
import '../models/closet_model.dart';
import '../models/closet_item_model.dart';

class ClosetRepositoryImpl implements ClosetRepository {
  final ClosetRemoteDataSource remoteDataSource;

  ClosetRepositoryImpl(this.remoteDataSource);

  @override
  Future<Either<Failure, List<ClosetEntity>>> getClosets() async {
    try {
      final closets = await remoteDataSource.getClosets();
      return Right(closets);
    } catch (e) {
      return Left(ErrorHandler.handleError(e));
    }
  }

  @override
  Future<Either<Failure, ClosetEntity>> getClosetById(String id) async {
    try {
      final closet = await remoteDataSource.getClosetById(id);
      return Right(closet);
    } catch (e) {
      return Left(ErrorHandler.handleError(e));
    }
  }

  @override
  Future<Either<Failure, ClosetEntity>> createCloset({
    required String name,
    required String type,
    String? image,
    String? description,
  }) async {
    try {
      final closetModel = ClosetModel(
        id: '', // Will be generated by server
        name: name,
        type: type,
        image: image,
        userId: '', // Will be set by server from auth token
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        description: description,
      );

      final result = await remoteDataSource.createCloset(closetModel);
      return Right(result);
    } catch (e) {
      return Left(ErrorHandler.handleError(e));
    }
  }

  @override
  Future<Either<Failure, ClosetEntity>> updateCloset({
    required String id,
    String? name,
    String? type,
    String? image,
    String? description,
  }) async {
    try {
      // Get current closet first
      final currentCloset = await remoteDataSource.getClosetById(id);

      final updatedCloset = ClosetModel(
        id: currentCloset.id,
        name: name ?? currentCloset.name,
        type: type ?? currentCloset.type,
        image: image ?? currentCloset.image,
        userId: currentCloset.userId,
        createdAt: currentCloset.createdAt,
        updatedAt: DateTime.now(),
        itemCount: currentCloset.itemCount,
        description: description ?? currentCloset.description,
      );

      final result = await remoteDataSource.updateCloset(id, updatedCloset);
      return Right(result);
    } catch (e) {
      return Left(ErrorHandler.handleError(e));
    }
  }

  @override
  Future<Either<Failure, void>> deleteCloset(String id) async {
    try {
      await remoteDataSource.deleteCloset(id);
      return const Right(null);
    } catch (e) {
      return Left(ErrorHandler.handleError(e));
    }
  }

  @override
  Future<Either<Failure, List<ClosetItemEntity>>> getClosetItems(
    String closetId,
  ) async {
    try {
      final items = await remoteDataSource.getClosetItems(closetId);
      return Right(items);
    } catch (e) {
      return Left(ErrorHandler.handleError(e));
    }
  }

  @override
  Future<Either<Failure, ClosetItemEntity>> getClosetItemById(String id) async {
    try {
      final item = await remoteDataSource.getClosetItemById(id);
      return Right(item);
    } catch (e) {
      return Left(ErrorHandler.handleError(e));
    }
  }

  @override
  Future<Either<Failure, ClosetItemEntity>> createClosetItem({
    required String closetId,
    required String name,
    required String brand,
    required String category,
    required String color,
    required String size,
    required double price,
    required List<String> images,
    String? description,
    required String condition,
  }) async {
    try {
      final itemModel = ClosetItemModel(
        id: '', // Will be generated by server
        closetId: closetId,
        name: name,
        brand: brand,
        category: category,
        color: color,
        size: size,
        price: price,
        images: images,
        description: description,
        condition: condition,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final result = await remoteDataSource.createClosetItem(itemModel);
      return Right(result);
    } catch (e) {
      return Left(ErrorHandler.handleError(e));
    }
  }

  @override
  Future<Either<Failure, ClosetItemEntity>> updateClosetItem({
    required String id,
    String? name,
    String? brand,
    String? category,
    String? color,
    String? size,
    double? price,
    List<String>? images,
    String? description,
    String? condition,
    bool? isAvailable,
  }) async {
    try {
      // Get current item first
      final currentItem = await remoteDataSource.getClosetItemById(id);

      final updatedItem = ClosetItemModel(
        id: currentItem.id,
        closetId: currentItem.closetId,
        name: name ?? currentItem.name,
        brand: brand ?? currentItem.brand,
        category: category ?? currentItem.category,
        color: color ?? currentItem.color,
        size: size ?? currentItem.size,
        price: price ?? currentItem.price,
        images: images ?? currentItem.images,
        description: description ?? currentItem.description,
        condition: condition ?? currentItem.condition,
        isAvailable: isAvailable ?? currentItem.isAvailable,
        createdAt: currentItem.createdAt,
        updatedAt: DateTime.now(),
      );

      final result = await remoteDataSource.updateClosetItem(id, updatedItem);
      return Right(result);
    } catch (e) {
      return Left(ErrorHandler.handleError(e));
    }
  }

  @override
  Future<Either<Failure, void>> deleteClosetItem(String id) async {
    try {
      await remoteDataSource.deleteClosetItem(id);
      return const Right(null);
    } catch (e) {
      return Left(ErrorHandler.handleError(e));
    }
  }
}
